import java.math.BigInteger;
import java.util.*;

public class ShamirSecretSharing {
    
    /**
     * Point class to represent (x, y) coordinates
     */
    static class Point {
        BigInteger x, y;
        
        Point(BigInteger x, BigInteger y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    /**
     * Convert a number from given base to decimal (BigInteger)
     */
    public static BigInteger convertToDecimal(String value, int base) {
        return new BigInteger(value, base);
    }
    
    /**
     * Simple JSON parser for our specific format
     */
    public static Map<String, Object> parseJSON(String json) {
        Map<String, Object> result = new HashMap<>();
        
        // Remove whitespace and outer braces
        json = json.trim().replaceAll("\\s+", "");
        if (json.startsWith("{") && json.endsWith("}")) {
            json = json.substring(1, json.length() - 1);
        }
        
        // Split by top-level commas
        List<String> parts = new ArrayList<>();
        int braceCount = 0;
        int start = 0;
        
        for (int i = 0; i < json.length(); i++) {
            char c = json.charAt(i);
            if (c == '{') braceCount++;
            else if (c == '}') braceCount--;
            else if (c == ',' && braceCount == 0) {
                parts.add(json.substring(start, i));
                start = i + 1;
            }
        }
        if (start < json.length()) {
            parts.add(json.substring(start));
        }
        
        for (String part : parts) {
            int colonIndex = part.indexOf(':');
            if (colonIndex > 0) {
                String key = part.substring(0, colonIndex).replace("\"", "");
                String value = part.substring(colonIndex + 1);
                
                if (value.startsWith("{") && value.endsWith("}")) {
                    result.put(key, parseJSON(value));
                } else {
                    result.put(key, value.replace("\"", ""));
                }
            }
        }
        
        return result;
    }
    
    /**
     * Parse input and extract points
     */
    @SuppressWarnings("unchecked")
    public static List<Point> parseInput(String jsonInput) {
        Map<String, Object> json = parseJSON(jsonInput);
        Map<String, Object> keys = (Map<String, Object>) json.get("keys");
        int n = Integer.parseInt((String) keys.get("n"));
        
        List<Point> points = new ArrayList<>();
        
        for (int i = 1; i <= n; i++) {
            String key = String.valueOf(i);
            if (json.containsKey(key)) {
                Map<String, Object> point = (Map<String, Object>) json.get(key);
                int base = Integer.parseInt((String) point.get("base"));
                String value = (String) point.get("value");
                
                BigInteger x = BigInteger.valueOf(i);
                BigInteger y = convertToDecimal(value, base);
                points.add(new Point(x, y));
            }
        }
        
        return points;
    }
    
    /**
     * Lagrange interpolation to find the constant term of polynomial
     * This gives us f(0) which is the secret
     */
    public static BigInteger lagrangeInterpolation(List<Point> points, int k) {
        // We only need k points for interpolation
        List<Point> selectedPoints = points.subList(0, Math.min(k, points.size()));
        
        BigInteger result = BigInteger.ZERO;
        
        for (int i = 0; i < selectedPoints.size(); i++) {
            Point pi = selectedPoints.get(i);
            BigInteger term = pi.y;
            
            // Calculate Lagrange basis polynomial Li(0)
            BigInteger numerator = BigInteger.ONE;
            BigInteger denominator = BigInteger.ONE;
            
            for (int j = 0; j < selectedPoints.size(); j++) {
                if (i != j) {
                    Point pj = selectedPoints.get(j);
                    // For f(0): numerator *= (0 - xj) = -xj
                    numerator = numerator.multiply(pj.x.negate());
                    // denominator *= (xi - xj)
                    denominator = denominator.multiply(pi.x.subtract(pj.x));
                }
            }
            
            // term = yi * (numerator / denominator)
            term = term.multiply(numerator).divide(denominator);
            result = result.add(term);
        }
        
        return result;
    }
    
    /**
     * Solve for the secret given JSON input
     */
    @SuppressWarnings("unchecked")
    public static BigInteger solveSecret(String jsonInput) {
        Map<String, Object> json = parseJSON(jsonInput);
        Map<String, Object> keys = (Map<String, Object>) json.get("keys");
        int k = Integer.parseInt((String) keys.get("k"));
        
        List<Point> points = parseInput(jsonInput);
        
        if (points.size() < k) {
            throw new IllegalArgumentException("Not enough points to reconstruct secret");
        }
        
        return lagrangeInterpolation(points, k);
    }
    
    /**
     * Test with the provided test cases
     */
    public static void main(String[] args) {
        // Test Case 1
        String testCase1 = "{ \"keys\": { \"n\": 4, \"k\": 3 }, \"1\": { \"base\": \"10\", \"value\": \"4\" }, \"2\": { \"base\": \"2\", \"value\": \"111\" }, \"3\": { \"base\": \"10\", \"value\": \"12\" }, \"6\": { \"base\": \"4\", \"value\": \"213\" } }";
        
        System.out.println("=== TEST CASE 1 ===");
        try {
            List<Point> points1 = parseInput(testCase1);
            System.out.println("Parsed points:");
            for (Point p : points1) {
                System.out.println("  " + p);
            }
            
            BigInteger secret1 = solveSecret(testCase1);
            System.out.println("Secret (constant term): " + secret1);
        } catch (Exception e) {
            System.out.println("Error in test case 1: " + e.getMessage());
            e.printStackTrace();
        }
        
        System.out.println();
        
        // Test Case 2
        String testCase2 = "{ \"keys\": { \"n\": 10, \"k\": 7 }, \"1\": { \"base\": \"6\", \"value\": \"13444211440455345511\" }, \"2\": { \"base\": \"15\", \"value\": \"aed7015a346d635\" }, \"3\": { \"base\": \"15\", \"value\": \"6aeeb69631c227c\" }, \"4\": { \"base\": \"16\", \"value\": \"e1b5e05623d881f\" }, \"5\": { \"base\": \"8\", \"value\": \"316034514573652620673\" }, \"6\": { \"base\": \"3\", \"value\": \"2122212201122002221120200210011020220200\" }, \"7\": { \"base\": \"3\", \"value\": \"20120221122211000100210021102001201112121\" }, \"8\": { \"base\": \"6\", \"value\": \"20220554335330240002224253\" }, \"9\": { \"base\": \"12\", \"value\": \"45153788322a1255483\" }, \"10\": { \"base\": \"7\", \"value\": \"1101613130313526312514143\" } }";
        
        System.out.println("=== TEST CASE 2 ===");
        try {
            List<Point> points2 = parseInput(testCase2);
            System.out.println("Parsed points (first 3):");
            for (int i = 0; i < Math.min(3, points2.size()); i++) {
                System.out.println("  " + points2.get(i));
            }
            System.out.println("  ... and " + (points2.size() - 3) + " more points");
            
            BigInteger secret2 = solveSecret(testCase2);
            System.out.println("Secret (constant term): " + secret2);
        } catch (Exception e) {
            System.out.println("Error in test case 2: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
